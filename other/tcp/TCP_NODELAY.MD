TCP_NODELAY
If set, disable the Nagle algorithm. This means that segments are always sent as soon as possible, even if there is only a small amount of data. When not set, data is buffered until there is a sufficient amount to send out, thereby avoiding the frequent sending of small packets, which results in poor utilization of the network. This option is overridden by TCP_CORK; however, setting this option forces an explicit flush of pending output, even if TCP_CORK is currently set.

30年前，阳澄湖的蟹农老王，每抓一只大闸蟹，就雇佣机器人开着卡车送到上海，然后再带着卖蟹的钱回来，老王想，这样好处是回款快（延迟小）。但是，30年前的乡间小路，很快被一辆辆的卡车所堵塞，结果三天三夜也没有到达上海，老王的如意算盘泡汤了。痛定思痛，老王觉得，没有必要一个螃蟹一辆车，可以将上午的所有螃蟹装在一辆卡车，上午发车；下午抓的螃蟹装在另一辆卡车里，下午发车。这样即使一天抓1000个螃蟹，也只需要两卡车，而不需要1000辆卡车。这样，乡间的小路也不会造成拥堵，上午发货，不一会儿，卖蟹的钱会被卡车运回来。以上就是Nagle算法的通俗解释。70-80年代，一些远程交互式软件，如Rlogin，客户端将用户输入的每一个字符独立传输到服务器端，服务器端再将这一个字符发回来，rlogin再显示到用户屏幕上。这样一个字节的字符却需要20字节的IP+ 20字节的TCP头，这样的传输效率非常低下，只有 1/41 = 2.43%。更要命的是，那时网络带宽特别窄，这样的传输模式很容易将窄窄的带宽挤满而丢包，再重传、再丢包的恶性循环。于是Nagle发明了一个算法，针对交互式应用，将用户敲入的字符缓存一下，聚集了几个字符放在一起发送，这样传输效率则高得多，唯一的不足是，可能会有一些延迟。为了避免延迟过大，等待用户时间由定时器控制，比如100-200毫秒，定时器到了，立马将缓冲区的数据发送出去。但记住一点，Nagle算法是时代的产物，因为当时网络带宽有限。而当前的局域网、广域网的带宽则宽裕得多，所以目前的TCP/IP协议栈默认将Nagle算法关闭，即通过SO_NODELAY = 1。这就好比，现在老王用一辆卡车运一只螃蟹，走沿海高速也不会堵，尽管这听起来很荒诞…